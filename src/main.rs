use std::f32::consts::PI;

use bevy::{
    core_pipeline::Skybox,
    prelude::*,
    render::{renderer::RenderDevice, texture::CompressedImageFormats},
};
use bevy_inspector_egui::quick::WorldInspectorPlugin;
use bevy_rapier3d::prelude::*;

mod models;

#[derive(Clone, Eq, PartialEq, Debug, Hash, Default, States)]
enum GameStates {
    #[default]
    AssetLoading,
    Next,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(WorldInspectorPlugin::new())
        .add_plugins(RapierPhysicsPlugin::<NoUserData>::default())
        .add_plugins(RapierDebugRenderPlugin::default())
        .add_plugins(models::ModelsPlugin)
        .add_state::<GameStates>()
        .add_systems(OnEnter(GameStates::Next), (setup_camera, setup))
        .add_systems(
            Update,
            (camera_controller, animate_light_direction).run_if(in_state(GameStates::Next)),
        )
        .run();
}

fn setup_camera(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    render_device: Res<RenderDevice>,
) {
    // directional 'sun' light
    commands.spawn(DirectionalLightBundle {
        directional_light: DirectionalLight {
            illuminance: 32000.0,
            ..default()
        },
        transform: Transform::from_xyz(0.0, 2.0, 0.0)
            .with_rotation(Quat::from_rotation_x(-PI / 4.)),
        ..default()
    });

    // environment map, use an appropriate colour and brightness to match
    commands.insert_resource(AmbientLight {
        color: Color::rgb_u8(210, 220, 240),
        brightness: 0.3,
    });

    // Cubemap is generated by https://github.com/petrocket/spacescape, http://alexcpeterson.com/spacescape/
    // And encoded to ktx2 with ASTC encoding and zstd compression using https://github.com/KhronosGroup/KTX-Software:
    // `toktx --encode astc --astc_blk_d 4x4 --zcmp 19 --cubemap background posx.png negx.png posy.png negy.png posz.png negz.png`
    // Comparing to the simple PNG this saves 50Mb of RAM usage during runtime.
    assert!(
        CompressedImageFormats::from_features(render_device.features())
            .contains(CompressedImageFormats::ASTC_LDR)
    );
    let skybox_image = asset_server.load("textures/space_cubemap_astc.ktx2");

    commands.spawn((
        Camera3dBundle {
            transform: Transform::from_xyz(0.0, 0.0, 8.0).looking_at(Vec3::ZERO, Vec3::Y),
            ..default()
        },
        CameraController::default(),
        Skybox(skybox_image),
        // todo: specify environment light according to the skybox
        // see the scene_viewer example for more details:
        // EnvironmentMapLight {
        //     diffuse_map: asset_server.load("assets/environment_maps/pisa_diffuse_rgb9e5_zstd.ktx2"),
        //     specular_map: asset_server
        //         .load("assets/environment_maps/pisa_specular_rgb9e5_zstd.ktx2"),
        // },
    ));
}

fn setup(mut commands: Commands, models: Res<models::Models>) {
    commands
        .spawn(SceneBundle {
            scene: models.zenith_station.clone(),
            ..default()
        })
        .insert(TransformBundle::from(Transform {
            translation: -200.0 * Vec3::Z,
            ..default()
        }))
        .insert(Name::new("Zenith station"));

    commands
        .spawn(SceneBundle {
            scene: models.praetor.clone(),
            ..default()
        })
        .insert(TransformBundle::from(Transform {
            translation: Vec3::new(5.0, 5.0, -20.0),
            ..default()
        }))
        .insert(Name::new("Praetor"));

    commands
        .spawn(SceneBundle {
            scene: models.infiltrator.clone(),
            ..default()
        })
        .insert(TransformBundle::from(Transform {
            translation: Vec3::new(-5.0, 5.0, -20.0),
            ..default()
        }))
        .insert(Name::new("Infiltrator"));

    commands
        .spawn(SceneBundle {
            scene: models.dragoon.clone(),
            ..default()
        })
        .insert(TransformBundle::from(Transform {
            translation: Vec3::new(0.0, 5.0, 150.0),
            ..default()
        }))
        .insert(Name::new("Dragoon"));
}

fn animate_light_direction(
    time: Res<Time>,
    mut query: Query<&mut Transform, With<DirectionalLight>>,
) {
    for mut transform in &mut query {
        transform.rotate_y(time.delta_seconds() * 0.5);
    }
}

#[derive(Component)]
struct CameraController {
    key_accelerate: KeyCode,
    key_decelerate: KeyCode,
    key_strafe_left: KeyCode,
    key_strafe_right: KeyCode,
    key_strafe_up: KeyCode,
    key_strage_down: KeyCode,
    key_rotate_clockwise: KeyCode,
    key_rotate_counter_clockwise: KeyCode,
    key_run: KeyCode,
}

impl Default for CameraController {
    fn default() -> Self {
        Self {
            key_accelerate: KeyCode::X,
            key_decelerate: KeyCode::Z,
            key_strafe_left: KeyCode::A,
            key_strafe_right: KeyCode::D,
            key_strafe_up: KeyCode::W,
            key_strage_down: KeyCode::S,
            key_rotate_clockwise: KeyCode::E,
            key_rotate_counter_clockwise: KeyCode::Q,
            key_run: KeyCode::ShiftLeft,
        }
    }
}

fn camera_controller(
    time: Res<Time>,
    keys: Res<Input<KeyCode>>,
    mouse: Res<Input<MouseButton>>,
    mut mouse_guidance: Local<bool>,
    mut windows: Query<&mut Window>,
    mut egui: bevy_inspector_egui::bevy_egui::EguiContexts,
    mut camera_controller: Query<(&mut Transform, &CameraController), With<Camera>>,
) {
    let (mut transform, config) = camera_controller.single_mut();

    let camera_speed = if keys.pressed(config.key_run) {
        80.0
    } else {
        20.0
    };
    let camepa_step = camera_speed * time.delta_seconds();

    let mut translation = Vec3::ZERO;
    if keys.pressed(config.key_strafe_up) {
        translation.y += camepa_step;
    }
    if keys.pressed(config.key_strage_down) {
        translation.y -= camepa_step;
    }
    if keys.pressed(config.key_strafe_left) {
        translation.x -= camepa_step;
    }
    if keys.pressed(config.key_strafe_right) {
        translation.x += camepa_step;
    }
    if keys.pressed(config.key_accelerate) {
        translation.z -= camepa_step;
    }
    if keys.pressed(config.key_decelerate) {
        translation.z += camepa_step;
    }

    let rotation_step = std::f32::consts::PI * time.delta_seconds();
    let mut rotation = Quat::IDENTITY;
    if keys.pressed(config.key_rotate_counter_clockwise) {
        rotation *= Quat::from_rotation_z(rotation_step);
    }
    if keys.pressed(config.key_rotate_clockwise) {
        rotation *= Quat::from_rotation_z(-rotation_step);
    }

    // Enable mouse guidance if Space is pressed
    if keys.just_released(KeyCode::Space) {
        *mouse_guidance = !*mouse_guidance;
    }

    let click_guidance = !egui.ctx_mut().is_pointer_over_area()
        && !egui.ctx_mut().is_using_pointer()
        && mouse.pressed(MouseButton::Left);
    if *mouse_guidance || click_guidance {
        let window = windows.single_mut();

        if let Some(pos) = window.cursor_position() {
            let center = Vec2::new(window.width() / 2.0, window.height() / 2.0);
            let offset = center - pos;

            // Safe zone around screen center for mouse_guidance mode
            if click_guidance || offset.length_squared() > 400.0 {
                let step = 0.3 * time.delta_seconds();
                rotation *= Quat::from_rotation_y(offset.x.to_radians() * step);
                rotation *= Quat::from_rotation_x(offset.y.to_radians() * step);
            }
        }
    }

    transform.rotate_local(rotation);
    translation = transform.rotation * translation;
    transform.translation += translation;
}
