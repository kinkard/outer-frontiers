use bevy::{
    ecs::world::Command,
    prelude::*,
    render::{
        mesh::VertexAttributeValues,
        render_resource::{TextureViewDescriptor, TextureViewDimension},
        renderer::RenderDevice,
        texture::CompressedImageFormats,
    },
    scene::SceneInstance,
    utils::HashMap,
};
use bevy_asset_loader::prelude::*;
use bevy_rapier3d::prelude::*;

use crate::GameStates;

/// A collection of assets related to the game environment, such as skybox cubemap texture.
#[derive(AssetCollection, Resource)]
pub(crate) struct Environment {
    /// Skybox cubemap texture depending on the platform supported compression format (ASTC_LDR or PNG).
    /// See [`resolve_supported_skybox_image()`] for more details.
    #[asset(key = "skybox_image")]
    pub(crate) skybox_image: Handle<Image>,
}

/// A collection of assets related to the game models.
#[derive(AssetCollection, Resource)]
pub(crate) struct Models {
    #[asset(path = "models/zenith_station.glb#Scene0")]
    pub(crate) zenith_station: Handle<Scene>,
    #[asset(path = "models/praetor.glb#Scene0")]
    pub(crate) praetor: Handle<Scene>,
    #[asset(path = "models/infiltrator.glb#Scene0")]
    pub(crate) infiltrator: Handle<Scene>,
    #[asset(path = "models/dragoon.glb#Scene0")]
    pub(crate) dragoon: Handle<Scene>,
}

pub(crate) struct AssetsPlugin;
impl Plugin for AssetsPlugin {
    fn build(&self, app: &mut App) {
        app.add_loading_state(
            LoadingState::new(GameStates::AssetLoading)
                .continue_to_state(GameStates::Next)
                .load_collection::<Models>()
                .load_collection::<Environment>(),
        )
        .add_systems(
            OnEnter(GameStates::AssetLoading),
            resolve_supported_skybox_image,
        )
        .add_systems(
            OnExit(GameStates::AssetLoading),
            (fix_png_skybox_metadata, extract_model_colliders),
        )
        .init_resource::<ModelColliders>()
        // From bevy 0.12 scene_spawner runs between Update and PostUpdate so we can set colliders
        // and setup scene in the same frame scene was spawned
        .add_systems(PostUpdate, (set_model_collider, setup_scene));
    }
}

fn resolve_supported_skybox_image(
    render_device: Res<RenderDevice>,
    mut dynamic_assets: ResMut<DynamicAssets>,
) {
    // Cubemap is generated by https://github.com/petrocket/spacescape, http://alexcpeterson.com/spacescape/
    let skybox_image = if CompressedImageFormats::from_features(render_device.features())
        .contains(CompressedImageFormats::ASTC_LDR)
    {
        // Encoded to ktx2 with ASTC encoding and zstd compression using https://github.com/KhronosGroup/KTX-Software:
        // `toktx --encode astc --astc_blk_d 4x4 --zcmp 19 --cubemap background posx.png negx.png posy.png negy.png posz.png negz.png`
        // This compression saves 50Mb of RAM usage during runtime comparing to the simple PNG.
        "textures/space_cubemap_astc.ktx2"
    } else {
        // Unfortunately, some platforms do not support ASTC_LDR compression format, so we fallback to PNG in this case
        debug!("ASTC_LDR is not supported, falling back to PNG");
        "textures/space_cubemap.png"
    };

    dynamic_assets.register_asset(
        "skybox_image",
        Box::new(StandardDynamicAsset::File {
            path: skybox_image.to_owned(),
        }),
    );
}

// PNGs do not have any metadata that could indicate they contain a cubemap texture,
// so they appear as one texture. The following code reconfigures the texture as necessary.
fn fix_png_skybox_metadata(mut images: ResMut<Assets<Image>>, environment: Res<Environment>) {
    let image = images.get_mut(&environment.skybox_image).unwrap();
    if image.texture_descriptor.array_layer_count() == 1 {
        image.reinterpret_stacked_2d_as_array(image.height() / image.width());
        image.texture_view_descriptor = Some(TextureViewDescriptor {
            dimension: Some(TextureViewDimension::Cube),
            ..default()
        });
    }
}

fn extract_mesh_vertices(mesh: &Mesh) -> Option<Vec<Vec3>> {
    match mesh.attribute(Mesh::ATTRIBUTE_POSITION)? {
        VertexAttributeValues::Float32(vtx) => {
            Some(vtx.chunks(3).map(|v| Vec3::new(v[0], v[1], v[2])).collect())
        }
        VertexAttributeValues::Float32x3(vtx) => {
            Some(vtx.iter().map(|v| Vec3::new(v[0], v[1], v[2])).collect())
        }
        _ => None,
    }
}

// fn extract_mesh_indices(mesh: &Mesh) -> Option<Vec<[u32; 3]>> {
//     match mesh.indices() {
//         Some(Indices::U16(idx)) => Some(
//             idx.chunks_exact(3)
//                 .map(|i| [i[0] as u32, i[1] as u32, i[2] as u32])
//                 .collect(),
//         ),
//         Some(Indices::U32(idx)) => Some(idx.chunks_exact(3).map(|i| [i[0], i[1], i[2]]).collect()),
//         None => None,
//     }
// }

/// A workaround for rapier Colliders that are built on the game startup.
/// This collection is filled right after all scenes are loaded and then used
/// every time corresponding scene is spawned.
#[derive(Default, Resource)]
struct ModelColliders(HashMap<AssetId<Scene>, Collider>);

/// Extracts hulls (meshed with `_hull` or `_hull_<some number>` suffix),
/// builds rapier Collider from them and stores in the `ModelColliders`
#[cfg_attr(feature = "trace", tracing::instrument(skip_all))]
fn extract_model_colliders(
    mut scenes: ResMut<Assets<Scene>>,
    meshes: Res<Assets<Mesh>>,
    mut model_colliders: ResMut<ModelColliders>,
) {
    for (scene_id, scene) in scenes.iter_mut() {
        // Find all hulls in the scene
        let hulls = scene
            .world
            // There are two entities in the scene for each hull - mesh itself and parent Node.
            // Transforms are stored inside Node (which is parent to the Mesh)
            .query_filtered::<(Entity, &Name), Without<Handle<Mesh>>>()
            .iter(&scene.world)
            .filter_map(|(entity, name)| {
                if name.ends_with("_hull") || name.contains("_hull_") {
                    Some(entity)
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        let colliders = hulls
            .iter()
            .filter_map(|hull| {
                // todo: transforms should be combined from the root to handle nested hulls
                let transform = scene.world.get::<Transform>(*hull)?;
                let children = scene.world.get::<Children>(*hull)?;
                Some((transform.compute_affine(), children))
            })
            .flat_map(|(affine, children)| {
                children
                    .iter()
                    .filter_map(|entity| scene.world.get::<Handle<Mesh>>(*entity))
                    .map(|handle| meshes.get(handle).expect("broken mesh handle"))
                    .filter_map(extract_mesh_vertices)
                    // Transform Mesh points into world coordinates
                    .map(move |mut vertices| {
                        vertices
                            .iter_mut()
                            .for_each(|v| *v = affine.transform_point3(*v));
                        vertices
                    })
            })
            .map(|points| Collider::convex_hull(&points).unwrap())
            .map(|collider| (Vec3::ZERO, Quat::IDENTITY, collider))
            .collect::<Vec<_>>();

        if !colliders.is_empty() {
            model_colliders
                .0
                .insert(scene_id, Collider::compound(colliders));
        }

        // todo: we also want to clean up other resources as well, like Meshes
        for entity in hulls {
            // Don't forget to clean parent-child relations
            RemoveParent { child: entity }.apply(&mut scene.world);
            DespawnRecursive { entity }.apply(&mut scene.world);
        }
    }
}

/// Attaches rapier Collider to the scene entity once it is spawned
fn set_model_collider(
    mut commands: Commands,
    colliders: Res<ModelColliders>,
    spawned_scenes: Query<(Entity, &Handle<Scene>), Changed<Handle<Scene>>>,
) {
    for (entity, scene) in spawned_scenes.iter() {
        if let Some(collider) = colliders.0.get(&scene.id()) {
            commands.entity(entity).insert(collider.clone());
        }
    }
}

/// Component to attach setup function that will be invoked once scene is loaded.
/// Inspired by https://github.com/nicopap/bevy-scene-hook but with a bit different approach.
///
/// Example:
///
/// ```
/// commands
///     .spawn(SceneBundle {
///         scene: asset_server.load("my_scene.glb#Scene0"),
///         ..default()
///     })
///     .insert(SceneSetup::new(|commands, entities| {
///         entities
///             .iter()
///             .filter(|e| !e.contains::<Handle<Mesh>>()) // Skip GLTF Mesh entities
///             .filter_map(|e| e.get::<Name>().map(|name| (e.id(), name)))
///             .for_each(|(entity, name)| {
///                 if name.starts_with("Muzzle") {
///                     commands.entity(entity).insert(Muzzle);
///                 } else if name.starts_with("Body") {
///                     commands.entity(entity).insert(Body);
///                 } else if name.starts_with("Head") {
///                     commands.entity(entity).insert(Head);
///                 }
///             });
///     }));
/// ```
#[derive(Component)]
pub(crate) struct SceneSetup(Box<dyn Fn(&mut Commands, &[EntityRef]) + Send + Sync + 'static>);

impl SceneSetup {
    pub(crate) fn new<F: Fn(&mut Commands, &[EntityRef]) + Send + Sync + 'static>(
        setup_fn: F,
    ) -> Self {
        Self(Box::new(setup_fn))
    }
}

fn setup_scene(
    scenes: Query<(Entity, &Handle<Scene>, &SceneInstance, &SceneSetup)>,
    server: Res<AssetServer>,
    scene_manager: Res<SceneSpawner>,
    world: &World,
    mut commands: Commands,
) {
    for (entity, handle, instance, setup) in scenes.iter() {
        if server.is_loaded_with_dependencies(handle.id()) {
            let instance_entities = scene_manager.iter_instance_entities(**instance);
            let entities: Vec<_> = std::iter::once(entity)
                .chain(instance_entities)
                .filter_map(|e| world.get_entity(e))
                // storing result of filtering allows us to handle lifetime problems and
                // workaround `Box<dyn Iterator<Item = EntityRef>>` in function type declaration
                .collect();
            setup.0(&mut commands, &entities);
            commands.entity(entity).remove::<SceneSetup>();
        }
    }
}
